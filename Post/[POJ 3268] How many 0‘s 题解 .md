# [POJ 3268] How many 0‘s 题解  

链接[POJ 3268](http://poj.org/problem?id=3286)

#### 题意描述

> 输入多组l, r. 输出在[l,  r]这个区间中0出现了多少次.
>
> 数据以`-1 -1`结束.

####  题解

`数位dp`入门题qwq， 做法是分别枚举`r`和`l - 1`每一位的情况， 统计出每一位是`0`的情况数，然后用`r`的情况数减去`l - 1`的情况数就是结果了。

先举个例子: 求`23033之前`的0出现的情况数:

> 个位: 只需要判断3左边的情况数， 很显然(雾)一共有$2303  \times１$种情况 .
>
> 十位: 左边取1~230，右边可以取0~9， 一共有$230 \times 10$.
>
> 百位: 百位是0，情况变了，当左边取的是1~22，右边取0~99， 情况数是$21 \times 100$。 当左边取23，右边取0~33， 情况数是$1 \times 34$，一共是$22 \times100 + 1\times 34$ 种.
>
> 千位: 左边能取1~2，右边取0~999,  一共是$2\times1000$种情况.
>
> 万位: 最左边的一位不可能取０, 一共０种情况.
>
> 结果为: 8837

结论就很显然了，要分类讨论。

以个位为１，考虑数ｘ的第ｉ位是０的情况数时

* 当ｘ的第ｉ位不为０时，为$x / 10 ^ {i} \times 10 ^ {i - 1}$.


* 当ｘ的第ｉ位为０时，为$(x/10^i - 1) \times 10 ^ {i - 1} + x \mod 10^ {i-1} +1 $.

#### ps

 为了减少特判，在个位时我们的左边是1～2303, 所以有0的最小的情况是10，并没有考虑0的情况，所以我们求的其实是1～n的含0的情况数，这时候如果$l==0$的话，就需要返回-1，负负得正，相当于加上一次0的情况w. 

#### 代码

```cpp
#include <iostream>
using namespace std;
typedef long long ll;

ll p[20], a, b, ans, l, r;

inline void init() {
    p[0] = 1;
    for (int i = 1; i < 18; i++)
        p[i] = p[i - 1] * 10;
}

inline ll solve(ll x) {
    if (!~x) return -1; // b = 0, ans - -1
    ans = 0;
    for (int i = 1; p[i] <= x; i++) {
        l = x / p[i];
        r = x % p[i - 1];
        if (x % p[i] / p[i - 1])
            ans += l * p[i - 1];
        else
            ans += (l - 1) * p[i - 1] + r + 1;
    }
    return ans;
}

int main() {
    init();
    while (cin >> a >> b and (~a and ~b)) {
        printf("%lld\n", solve(b) - solve(a - 1));
    }
}
```